# Uniswap AMM Study

![](https://uniswap.org/images/twitter-card.jpg)

## What is Uniswap?

[Uniswap v2](https://uniswap.org/whitepaper.pdf) can create an exchange market between any two ERC-20 tokens. Uniswap is unique since it's an AMM and solve the problems of traditional market of liquidity. In this note, we will go over the source code for the contracts that implement this protocol and see why they are written this way.

## What Does Uniswap Do?

Basically, there are two types of users: **liquidity providers** and **traders**.

The _liquidity providers_ provide the pool with the two tokens that can be exchanged (we'll call them **Token0** and **Token1**). In return, they receive a third token that represents partial ownership of the pool called a _liquidity token_.

_Traders_ send one type of token to the pool and receive the other (for example, send **Token0** and receive **Token1**) out of the pool provided by the liquidity providers. The exchange rate is determined by the relative number of **Token0**s and **Token1**s that the pool has. In addition, the pool takes a small percent as a reward for the liquidity pool.

When liquidity providers want their assets back they can burn the pool tokens and receive back their tokens, including their share of the rewards.

## What's AMM?

Automated market makers (AMMs) allow digital assets to be traded without permission and automatically by using liquidity pools instead of a traditional market of buyers and sellers. On a traditional exchange platform, buyers and sellers offer up different prices for an asset. When other users find a listed price to be acceptable, they execute a trade and that price becomes the asset's market price. Stocks, gold, real estate, and most other assets rely on this traditional market structure for trading. However, AMMs have a different approach to trading assets.

AMMs are a financial tool unique to Ethereum and decentralized finance (DeFi). This new technology is decentralized, always available for trading, and does not rely on the traditional interaction between buyers and sellers. This new method of exchanging assets embodies the ideals of Ethereum, crypto, and blockchain technology in general: no one entity controls the system, and anyone can build new solutions and participate.

**Source**: [What Are Automated Market Makers?](https://www.gemini.com/cryptopedia/amm-what-are-automated-market-makers#section-liquidity-pools-and-liquidity-providers)

## How does Uniswap work?

The whole purpose of Uniswap is to allow you to swap one ERC20 token for another. For example, you need Dogecoin but you only have Shiba coin. Uniswap allows you to sell your Shiba and get Dogecoin in return. This is all done in an automatic and decentralized fashion. Uniswap is just a **decentralized exchange (DEX)**.

Exchanges can be implemented in two ways.

1. **Order book model**: Buyers and sellers file orders. And the centralized system matches the buy orders to the sell orders. This is how the traditional stock exchange works.
2. **Automated market makers (AMM)**: There is no centralized matchmaker. There are people who provide both tokens (Dogecoin and Shiba). They are called liquidity providers. These liquidity providers create a pool of Dogecoin and Shiba tokens. Now traders can come and deposit Dogecoin and get Shiba in return. This is done automatically, without a centralized entity. Traders pay a small percentage fee for the trade which goes to liquidity providers for their services.

Uniswap uses the AMM technique. How does it determine the exchange rate in a pool? i.e. how many Shiba tokens is 1 Dogecoin worth? This is determined by the constant product formula (Dogecoin amount)\*(Shiba amount)=k. During trades, this product must remain constant.

![](https://miro.medium.com/max/770/1*VcZyp1TBYtZrYi47ozJxRw@2x.png)

Image Source: [Uniswap — A Unique Exchange](https://medium.com/scalar-capital/uniswap-a-unique-exchange-f4ef44f807bf)

**Source**: [How Uniswap works at a high level](https://betterprogramming.pub/uniswap-smart-contract-breakdown-ea20edf1a0ff)

## Uniswap v2 Source Code Analysis

Uniswap has 4 smart contracts in total. They are divided into **core** and **periphery**.

1. **Core** is for storing the funds (the tokens) and exposing functions for swapping tokens, adding funds, getting rewards, etc.
2. **Periphery** is for interacting with the **core**.

This division allows the **core** contracts, which hold the assets and therefore **_have_** to be secure, to be simpler and easier to audit. All the extra functionality required by traders can then be provided by **periphery** contracts.

![](https://miro.medium.com/max/770/1*WbCK5HMsPexKYuZxujx1Rg.png)

## Uniswap Functionality

1. **Managing the funds** (how tokens such as Dogecoin and Shiba are managed in the pool)
2. Functions for **liquidity providers** — deposit more funds and withdraw the funds along with the rewards
3. Functions for **traders** — swapping
4. **Managing pool ownership (ERC20) tokens**
5. **Protocol fee** — Uniswap v2 introduced a switchable protocol fee.
6. **Price oracle** — Uniswap tracks prices of tokens relative to each other and can be used as a price oracle for other smart contracts in the Ethereum ecosystem.

## Core contracts: Pair

<CH.Scrollycoding>

It imports interfaces that the contract needs to know about, either because the contract implements them (`IUniswapV2Pair` and `UniswapV2ERC20`) or because it calls contracts that implement them.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=3:4,7:9
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';

contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;
```

---

It also imports libraries for dealing with math. `SafeMath` is a library for dealing with overflow/underflow. `UQ112x112` is a library for supporting floating numbers. Solidity does not support floats by default. This library represents floats using 224 bits. The First 112 bits are for the whole number, and the last 112 bits are for the fractional part.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=5:6
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';

contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;
```

</CH.Scrollycoding>

It implements the `IUniswapV2Pair` interface, which is just an interface for this contract. It also extends the `UniswapV2ERC20` contract. This contract inherits from `UniswapV2ERC20`, which provides the the ERC-20 functions for the liquidity tokens.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=1
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;
```

### Managing the funds

A Uniswap Pair is an exchange between a pair of tokens such as Dogecoin and Shiba. These tokens are represented as `token0` and `token1` in the contract. They are the addresses of the ERC20 smart contracts that implement them.

`reserve` variables store how much of the token we have in this Pair.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=9:10,12:13
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;

    uint public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

    address public factory;
    address public token0;
    address public token1;

    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
```

![](https://miro.medium.com/max/770/1*j4T8KVmNZhDekIC8O_zNtw.png)

This is how funds are managed across 3 smart contracts. [Source](https://betterprogramming.pub/uniswap-smart-contract-breakdown-ea20edf1a0ff)

The Pair contract calls ERC20's functions such as `balanceOf` (with `owner=Pair contract's address`) and `transfer` to manage the tokens (read [Core contracts: ERC20](/UniSwap_AMM_Study#core-contracts-erc20) for detailed breakdown of Uniswap ERC20 contract). Here is an example of how ERC20's transfer function is used in the Pair contract.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=6,14:17 mark=6[64:71] mark=15[79:97]
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;

    uint public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

    address public factory;
    address public token0;
    address public token1;

    ...

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

The `_update` function below is called whenever there are new funds deposited or withdrawn by the liquidity providers or tokens are swapped by the traders.

All we do in this function is check for overflow (line 3), **update price oracle**, **update reserves**, and update a `Sync` event.

### Update price oracle

Uniswap implements a price oracle that can be used by other smart contracts in the Ethereum ecosystem to query the price of tokens relative to each other.

To implement the price oracle, Uniswap uses only 3 variables: `price0CumulativeLast`, `price1CumulativeLast`, and `blockTimestampLast`.

The relative price can be calculated by subtracting cumulative prices at 2 points in time and dividing by the elapsed time. Check the [Uniswap whitepaper's](https://uniswap.org/whitepaper.pdf) “Price oracle” section for more details.

The variables are updated only once per block here:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=1,3:4,11:17,20
uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves

uint public price0CumulativeLast;
uint public price1CumulativeLast;

...

// update reserves and, on the first call per block, price accumulators
function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
```

Lines 11-13 calculate whether this is the first time the code is executed in a particular block.

Why do we update values only once per block? Because it's harder that way for someone to manipulate prices in order to gain something. See the “Price oracle” section of the [Uniswap whitepaper](https://uniswap.org/whitepaper.pdf) for more details on these price manipulators.

Each cost accumulator is updated with the latest cost (reserve of the other token/reserve of this token) times the elapsed time in seconds. To get an average price you read the cumulative price is two points in time, and divide by the time difference between them. Let's say we want to calculate the average price of **Token0** between the timestamps 5,030 and 5,150. The difference in the value of `price0Cumulative` is 143.702-29.07=114.632. This is the average across two minutes (120 seconds). So the average price is 114.632/120 = 0.955.

### Update reserves

- `balance0` and `balance1` are the balances of tokens in the ERC20. They are the return value of ERC20's `balanceOf` function.
- `_reserve0` and `_reserve1` are Uniswap's previously known balances (last time balanceOf was checked).

```solidity v2-core/contracts/UniswapV2Pair.sol focus=6,11:12
// update reserves and, on the first call per block, price accumulators
function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
```

What's the difference between the arguments `_reserve0`, `_reserve1` and the stored variables `reserve0`, `reserve1` (shown below)? They are essentially the same. The callers of the `_update` function already have read the `reserve` variables from storage and just pass them as arguments to the `_update` function. This is just a way to save on gas. Reading from storage is more expensive than reading from memory.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=5:6
address public factory;
address public token0;
address public token1;

uint112 private reserve0;           // uses single storage slot, accessible via getReserves
uint112 private reserve1;           // uses single storage slot, accessible via getReserves
uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
```

---

### Minting and Burning

Minting is when a liquidity provider adds funds to the pool and as a result, new pool ownership tokens are minted (created out of thin air) for the liquidity provider. Burning is the opposite — liquidity provider withdraws funds (and the accumulated rewards) and his pool ownership tokens are burned (destroyed).

Let's take a look at the `mint` function.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=6:7,11:18
// this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
        _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    } else {
        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
    }
    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}
```

- Gas savings: `reserve0`, `reserve1`, and `totalSupply` are transferred from storage to memory (lines 3 and 10) so that it's cheaper to read these values.
- We read the balances of our contract (the Pair contract) on lines 4 and 5 and then calculate the amount of each token that was deposited.
- `totalSupply` indicates the total supply of the pool ownership tokens and is a stored variable in the `UniswapV2ERC20` contract. The Pair contract extends `UniswapV2ERC20` which is why it has access to the `totalSupply` variable.
- If `totalSupply` is 0, it means that this pool is brand new and we need to lock in `MINIMIUM_LIQUIDITY` amount of pool ownership tokens to avoid division by zero in the liquidity calculations. The way it's locked in is by sending it to the address zero. (no one knows the private key that will lead to the address zero so by sending funds to the address zero, you essentially lock the funds forever).
- **`liquidity` variable is the amount of new pool ownership tokens that need to be minted to the liquidity provider.** The liquidity provider gets a proportional amount of pool ownership tokens depending on how much new funds he provides (line 15)
- We finally mint new pool ownership tokens to the `to` address (line 18). `to` is the address of the liquidity provider (this will be provided by the Periphery contract called the Router which calls the `mint` function)

**The way adding funds works is**: funds are deposited to the ERC20 contracts (by calling transfer(from: liquidity provider's address, to: Pair contract's address, amount) for each token). Then the Pair contract will read the balances (lines 4 and 5) and compare them to the last known balances (lines 6 and 7). This is how the Pair contract can calculate the amounts deposited.

The `burn` function is just the mirror image of the `mint` function:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=6:8,11:17
// this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

- `balance0` and `balance1` are total balances of the tokens in this pool. `liquidity` is the amount of pool ownership tokens that the liquidity provider (who wishes to cash out) has. Why do access the liquidity as the balance of `address(this)`? Because the liquidity was transferred to the Pair contract by the Periphery contract before calling the `burn` function.
- We calculate the amounts of tokens to withdraw to the liquidity provider proportionally to how much liquidity (pool ownership tokens) they have (lines 12 and 13)
- We then burn their liquidity and transfer the tokens to them.
- Rewards to the liquidity provider are automatically withdrawn along with their funds. The math makes sure that rewards are accumulated properly and that you get more than you deposited.

---

### Swapping

The `swap` function is used by traders to swap tokens:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=2:5,12,13:15,19:21,23:25,28:29
// this low-level function should be called from a contract which performs important safety checks
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
    address _token0 = token0;
    address _token1 = token1;
    require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
    if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
    if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
    if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    }
    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
    { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
    uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
    uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
    require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

- First, we have a bunch of assertions
- Then on lines 13 and 14, **we transfer tokens out (to the trader) optimistically** (without making sure that the trader has already transferred corresponding tokens into our balance. We can optimistically transfer tokens out because we have assertions later in the function to check if we received corresponding tokens (the Periphery contract should send us the tokens before calling us for the swap). If we have not, assertions will fail and Solidity will revert the entire function.
- Line 15 will inform the receiver about the swap if requested.
- Then on lines 19 and 20 we actually check how many tokens we received. We assert that we received >0 amount for at least one token on line 21. If this assertion fails, the entire function will revert and nothing will have taken place.
- Then, on lines 23 and 24, we subtract the trading fee (0.3%) from the balance, and on line 25 check if the k value (x\*y=k) has decreased after the trade. The k value can never decrease because otherwise, Uniswap would lose from the swap.
- Finally, we update our known reserves with the new balances and emit a `Swap` event.

Note:

- [Stack Too Deep Error](https://medium.com/coinmonks/stack-too-deep-error-in-solidity-608d1bd6a1ea)

---

### Fees and Rewards

Uniswap works by taking a small percentage (0.3%) fee from the traders on each trade. It then later (optionally) takes some of those fees (1/6th) to itself and distributes the rest to the liquidity providers in proportion to how much the liquidity provider contributed to the pool.

Where are these fees/rewards stored? They are actually stored right in the pool itself.

When traders pay their fee, this fee is added to the pool. Later when liquidity providers either add or withdraw funds, the liquidity provider's rewards are calculated using complicated math formulas.

Instead of creating a separate pool/storage for the fees/rewards, they just add everything to the pool and then use clever math formulas to deduce how much of the pool is from the fees. And Uniswap has an efficient way of keeping track of absolutely the bare minimum to derive these values at any point in the future.

### Pool ownership tokens

When liquidity providers add funds to the pool, they are given pool ownership tokens. After some time, these ownership tokens gain in value due to traders' fees. When the tokens are exchanged back, liquidity providers get more than they deposited.

The pool ownership tokens are implemented as a standard ERC20 token. It's implemented in the UniswapV2ERC20.sol contract of Uniswap (v2-core/contracts/UniswapV2ERC20.sol).

See breakdown of Uniswap's ERC20 contract in a [section below](/UniSwap_AMM_Study#core-contracts-erc20)

The Pair contract gets access to the ERC20 implementation by extending it:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=5[43:56]
import './UniswapV2ERC20.sol';

...

contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;
```

That way the Pair contract gets access to ERC20's `_mint` and `_burn` functions:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=13,18
// this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
        _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    } else {
        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
    }
    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}
```

```solidity v2-core/contracts/UniswapV2Pair.sol focus=15
// this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

---

### Protocol fee

Uniswap v2 introduced a switchable protocol fee — a fee that can be turned on/off by Uniswap which goes to Uniswap for maintaining the service. It's equal to 1/6th of the fees paid by the traders. Let's examine how the protocol fee is handled in the Pair contract.

The main function of the protocol fee is `_mintFee`:

```solidity v2-core/contracts/UniswapV2Pair.sol focus=3:4,6,14
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
    uint _kLast = kLast; // gas savings
    if (feeOn) {
        if (_kLast != 0) {
            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
            uint rootKLast = Math.sqrt(_kLast);
            if (rootK > rootKLast) {
                uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                uint denominator = rootK.mul(5).add(rootKLast);
                uint liquidity = numerator / denominator;
                if (liquidity > 0) _mint(feeTo, liquidity);
            }
        }
    } else if (_kLast != 0) {
        kLast = 0;
    }
}
```

- We first get the `feeTo` address from the `factory`. `factory` is the contract that created this Pair contract.
- If it's set to something other than address zero, that means the protocol fee is on. `feeTo` address indicated the address where the protocol fee should be sent to.
- If the fee is on, we mint some liquidity to the `feeTo` address. (`_mint` function is the ERC20's `_mint` function)

The rest of the code is for calculating `liquidity`. Liquidity here indicates the amount of new pool ownership tokens that need to be minted to the `feeTo` address. This is how Uniswap implements the protocol fees: it just mints new pool ownership tokens to itself. That, in effect, dilutes everyone else in the pool (the liquidity providers).

`_mintFee` is not the best name for this function because it has a side effect of minting new liquidity. A better name would be `_collectProtocolFee`.

### How protocol fee is calculated

A straightforward way to implement the protocol fee would be to take 1/6th of the traders' fee every time there is a swap of tokens. But as you probably noticed, Uniswap does not like the easy way out. It absolutely loves efficiency and gas savings even if it means the code becomes 10x more complicated.

Uniswap does not calculate fees on every trade because that would incur extra gas on every single swap trade. Since there are lots and lots of trades happening every day, that would sum up to large amounts of gas cost. Uniswap instead calculates the protocol fee only when funds are either deposited or withdrawn from the pool by the liquidity providers. This is a much rarer event than the trades.

So the `_mintFee` function is called only from the `mint` and `burn` functions.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=9
// this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
```

```solidity v2-core/contracts/UniswapV2Pair.sol focus=10
// this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
```

Protocol fee is accumulated during trades into the pool so the pool becomes a mix of the exchange tokens, protocol fees, and rewards for liquidity providers. Clever math formulas allow us to calculate how much of each constituent there is.

The protocol fee, in particular, is calculated using a complicated formula which you can find the detailed math proof in the [Uniswap V2 whitepaper](https://uniswap.org/whitepaper.pdf):

![](https://miro.medium.com/max/1400/1*d5laZOk4QnKTcRRnyceXNg@2x.png)

The k value here is the product of the reserves (k=x\*y). This is why we keep track of the `kLast` value throughout the code: `kLast` value allows us to calculate the total accumulated protocol fee (from every trade) so far and collect all this fee in one go either in mint or burn functions.

---

### Pair Contract Misc.

A liquidity event is when funds are either added or withdrawn by the liquidity providers.

```solidity v2-core/contracts/UniswapV2Pair.sol focus=3 mark=3[84:98]
uint public price0CumulativeLast;
uint public price1CumulativeLast;
uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

uint private unlocked = 1;
```

`lock` is for guarding against [reentrancy abuse](https://medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14). Essentially this function modifier prevents 2 different parts of this contract to be executed simultaneously. It kinda makes the contract execute with a single thread. Learn more about [Modifiers](https://medium.com/coinmonks/solidity-tutorial-all-about-modifiers-a86cf81c14cb) in Solidity.

```solidity v2-core/contracts/UniswapV2Pair.sol
uint private unlocked = 1;
modifier lock() {
    require(unlocked == 1, 'UniswapV2: LOCKED');
    unlocked = 0;
    _;
    unlocked = 1;
}
```

`skim` and `sync` are needed when balances on the ERC20 contracts of the exchange tokens, fall out of sync with the `reserve` variables in the Pair contract. This can happen for example when someone just transfers some Dogecoin to Pair contract's account for no reason. There are 2 solutions to keep reserve variables in sync with the actual balances on ERC20 contracts:

- `skim` allows someone to withdraw the extra funds from the ERC20 contract. Anyone can call this function!
- `sync` updates the `reserve` variables to match the balances.

---

### A note on the market dynamics

Uniswap prices tokens according to the proportion of them in the pool. The greater disbalance of them in the pool the greater the price difference (in favor of the rarer token).

But how does Uniswap make sure that the relative price of tokens in the pool matches the market rate? **Arbitrage**. Uniswap takes advantage of arbitrage to ensure the prices in the pool closely track the market prices.

Arbitrage is when a smart investor sees a discrepancy between the market rate and Uniswap exchange rate, he will use it to make a profit and as a result, bring the Unsiwap rate closer to the market rate.

For example, if Uniswap offered a lower Dogecoin-to-Shiba price compared to the market rate, a smart investor would exchange his Shiba for Dogecoin on Uniswap and sell the Dogecoin at a higher price in the market. He will have made a profit and as a result, brought the Unsiwap rate closer to the market rate because he decreased the supply of Dogecoin and increased the supply of Shiba in the Uniswap pool (Dogecoin-to-Shiba price will increase because of how Uniswap price tokens relative to each other).

This will continue until the Uniswap rate matches the market rate. Thus Uniswap rate tends to closely track the market rate and that's why it can be used as an on-chain price oracle.

- As [Uniswap v2 whitepaper](https://uniswap.org/whitepaper.pdf) put it: The first liquidity provider to join a pool sets the initial exchange rate by depositing what they believe to be an equivalent value of ETH and ERC20 tokens. If this ratio is off, arbitrage traders will bring the prices to equilibrium at the expense of the initial liquidity provider.
- And [Uniswap v1 whitepaper](https://hackmd.io/@HaydenAdams/HJ9jLsfTz?type=view) put it: Large trades cause price slippage as well, but arbitrage will ensure that the price will not shift too far from that of other exchanges.

---

### Pair Contract Summary

The Pair contract is a mix of a bunch of functionality:

- Managing funds
- Adding/removing liquidity
- Swapping tokens
- Managing fees/rewards
- Calculating the protocol fee
- Implementing a price oracle

Fully annotated code for the Pair contract:

![](https://miro.medium.com/max/1400/1*kwkPAf-V8tGcCyTc7mD95A.png)

---

## Core contracts: Factory

![](https://miro.medium.com/max/1400/1*E1dBWKjmKzGiyuohaZU25Q@2x.png)

The Factory contract is referenced throughout the Pair contract:

![](https://miro.medium.com/max/1400/1*ITIXOfTmqfRTpS8StkD-tA@2x.png)
![](https://miro.medium.com/max/1400/1*i_xvaGlzFIH7d4p8jFTD2A@2x.png)

---

## Core contracts: ERC20

### What is a standard?

An Ethereum standard is just a standardized pattern of creating something on Ethereum.

A standard just says what should be done. But it does not specify the details (the how). It's like an interface in Java.

Why do we need standards? Mainly for **interoperability**. For example, wallets can write one code that will work with all tokens that follow the same ERC20 standard.

### What is the ERC20 standard?

ERC20 is a standard used for implementing arbitrary tokens. For example, Dogecoin, Shiba Inu, USDC, all use the ERC20 token standard.

More formally: **ERC20 is a standard for fungible tokens**. (fungible means all tokens are all the same). NFTs (non-fungible tokens) on the other hand are all unique.

> The ERC20 standard says that if a contract implements the functions below, then this contract can be considered a standard ERC20 token contract.

```solidity
function name() external pure returns (string memory);
function symbol() external pure returns (string memory);
function decimals() external pure returns (uint8);
function totalSupply() external view returns (uint);
function balanceOf(address owner) external view returns (uint);
function transfer(address to, uint value) external returns (bool);

function allowance(address owner, address spender) external view returns (uint);
function approve(address spender, uint value) external return (bool);
function transferFrom(address from, address to, uint value) external returns (bool);
```

- `name` is the name of the token like `“Dogecoin”`
- `symbol` is the symbol like `DOGE`
- `decimals` is the number of decimal points that the token has. The default value is 18. Ethereum also uses 18 decimal points (1 ETH = 10<sup>18</sup> wei).
- `totalSupply` is the total number of tokens measured in the smallest unit. For example, if there were only 5 ETH in total for ETH token, `totalSupply` should then return 5\*10<sup>18</sup>.
- `balanceOf` is the balance of the provided address also measured in the smallest unit.
- `transfer` is the function transferring the provided `value` (again measured in the smallest units) from the sender to the `to` address.

In combination, these functions cover the entire behavior of a token that can be used as a currency.

### How do Uniswap and implement ERC20?

Here is the Uniswap implementation of all functions of the standard except the `transfer` function.

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=9:13
pragma solidity =0.5.16;

import './interfaces/IUniswapV2ERC20.sol';
import './libraries/SafeMath.sol';

contract UniswapV2ERC20 is IUniswapV2ERC20 {
    using SafeMath for uint;

    string public constant name = 'Uniswap V2';
    string public constant symbol = 'UNI-V2';
    uint8 public constant decimals = 18;
    uint  public totalSupply;
    mapping(address => uint) public balanceOf;
```

These are just variables, you might say. Where are the actual function implementations? **The trick is that the getter functions are automatically generated by Solidity for public variables.** So there is no need to implement these functions manually. For example, you automatically get this function generated for the `name` variable:

```solidity
function name() external pure returns (string memory) {
    return name;
}
```

A correct getter function is also generated for the `balanceOf` [mapping](https://solidity-by-example.org/mapping/) so no need to implement that function either.

#### The `transfer` function

```solidity v2-core/contracts/UniswapV2ERC20.sol
function _transfer(address from, address to, uint value) private {
    balanceOf[from] = balanceOf[from].sub(value);
    balanceOf[to] = balanceOf[to].add(value);
    emit Transfer(from, to, value);
}

function transfer(address to, uint value) external returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
}
```

It's pretty self-explanatory except line 4 where we emit a `Transfer` event. [Events](https://www.tutorialspoint.com/solidity/solidity_events.htm) are used in Ethereum to monitor for certain events from a front end. For example, you might want to update the balance after the transfer goes through.

### Additional functionality: mint, burn

These functions are used to control the amount of currency in circulation. Let's see how they are implemented:

```solidity v2-core/contracts/UniswapV2ERC20.sol
function _mint(address to, uint value) internal {
    totalSupply = totalSupply.add(value);
    balanceOf[to] = balanceOf[to].add(value);
    emit Transfer(address(0), to, value);
}

function _burn(address from, uint value) internal {
    balanceOf[from] = balanceOf[from].sub(value);
    totalSupply = totalSupply.sub(value);
    emit Transfer(from, address(0), value);
}
```

### Additional functionality: allowances

The ERC20 standard actually has one more functionality that needs to be implemented by all tokens. I omitted it initially to simplify the explanation. Let's bring it back now.

The omitted functionality is **allowances**. Allowances allow someone else to withdraw funds from you. Where can this be useful?

Imagine Amazon was a dApp on Ethereum. It has one big smart contract that handles all sales. When you buy something from Amazon, Amazon's smart contract needs to withdraw tokens from you. But this is not possible on Ethereum. Amazon has no permission to initiate a transaction on behalf of someone else (you). They will need your private key or signature to initiate a transaction that will transfer your tokens to them.

**Allowances can help you solve this problem.** Here is how: Instead of sending the tokens to Amazon directly, you increase Amazon's allowance from you by the same amount. You then buy your product from Amazon. When you buy it, Amazon checks its allowance from you. If it's ≥ the product's price, Amazon will sell the product to you and withdraw the amount from you (the allowance will be decreased accordingly). Only Amazon has the right to spend the allowance.

You might argue that _you_ can transfer some tokens to Amazon's account directly. But Amazon's smart contract has no way of knowing the origin of the tokens that were just transferred to it. So we still need allowances.

This is why allowances were added as part of the ERC20 standard. Here are the functions that need to be implemented as part of the ERC20 standard:

```solidity focus=8:10
function name() external pure returns (string memory);
function symbol() external pure returns (string memory);
function decimals() external pure returns (uint8);
function totalSupply() external view returns (uint);
function balanceOf(address owner) external view returns (uint);
function transfer(address to, uint value) external returns (bool);

function allowance(address owner, address spender) external view returns (uint);
function approve(address spender, uint value) external return (bool);
function transferFrom(address from, address to, uint value) external returns (bool);
```

- `allowance` function returns the `spender`'s allowance from `owner`.
- `approve` function approves the `spender` an allowance of an amount equal to `value` from the sender
- `transferFrom` function is used by the spender to actually spend the allowance.

Here is how Uniswap implements these functions:

```solidity v2-core/contracts/UniswapV2ERC20.sol
mapping(address => mapping(address => uint)) public allowance;

...

function _approve(address owner, address spender, uint value) private {
    allowance[owner][spender] = value;
    emit Approval(owner, spender, value);
}

function approve(address spender, uint value) external returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
}

function transferFrom(address from, address to, uint value) external returns (bool) {
    if (allowance[from][msg.sender] != uint(-1)) {
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
    }
    _transfer(from, to, value);
    return true;
}
```

### Additional functionality: meta transactions

Uniswap contract implements another functionality that might be useful in some scenarios. This functionality is called **meta transactions**.

Transactions on Ethereum cost ether (ETH), which is equivalent to real money. If you have ERC-20 tokens but not ETH, you can't send transactions, so you can't do anything with them. One solution to avoid this problem is [meta transactions](https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/supporting-meta-transactions/). The owner of the tokens signs a transaction that allows somebody else to withdraw tokens off chain and sends it using the Internet to the recipient. The recipient, which does have ETH, then submits the permit on behalf of the owner.

Meta transactions allow you to sign an allowance transaction, send it to someone, and that someone can later submit your signed transaction to the contract and get an allowance from you on your behalf.

This hash is the [identifier for the transaction type](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash). The only one we support here is Permit with these parameters.

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=1:3
bytes32 public DOMAIN_SEPARATOR;
// keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
mapping(address => uint) public nonces;
```

It is not feasible for a recipient to fake a digital signature. However, it is trivial to send the same transaction twice (this is a form of [replay attack](https://wikipedia.org/wiki/Replay_attack)). To prevent this, we use a [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce). If the nonce of a new Permit is not one more than the last one used, we assume it is invalid.

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=4
bytes32 public DOMAIN_SEPARATOR;
// keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
mapping(address => uint) public nonces;
```

This is the code to retrieve the [chain identifier](https://chainlist.org/). It uses an EVM assembly dialect called [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html). Note that in the current version of Yul you have to use chainid(), not chainid.

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=1:5
constructor() public {
    uint chainId;
    assembly {
        chainId := chainid
    }
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
}
```

Calculate the [domain separator](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) for EIP-712.

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=6:14
constructor() public {
    uint chainId;
    assembly {
        chainId := chainid
    }
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
}
```

```solidity v2-core/contracts/UniswapV2ERC20.sol
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
    bytes32 digest = keccak256(
        abi.encodePacked(
            '\x19\x01',
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
        )
    );
    address recoveredAddress = ecrecover(digest, v, r, s);
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

- This is the function that implements the permissions. It receives as parameters the relevant fields, and the three scalar values for [the signature](https://yos.io/2018/11/16/ethereum-signatures/) (v, r, and s).
- Don't accept transactions after the deadline.
- Line 3 to 9: `abi.encodePacked(...)` is the message we expect to get. We know what the nonce should be, so there is no need for us to get it as a parameter. The Ethereum signature algorithm expects to get 256 bits to sign, so we use the keccak256 hash function.
- From the digest and the signature we can get the address that signed it using [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/).
- If everything is OK, treat this as [an ERC-20 approve](https://eips.ethereum.org/EIPS/eip-20#approve).

```solidity v2-core/contracts/UniswapV2ERC20.sol focus=10:12
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
    bytes32 digest = keccak256(
        abi.encodePacked(
            '\x19\x01',
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
        )
    );
    address recoveredAddress = ecrecover(digest, v, r, s);
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

All the code before these 3 lines is only needed to recover the address of the account that signed the signature. Once we recover the address, we check whether the address matches the provided `owner` address. If it does, we approve an allowance from `owner` to `spender` in the amount of `value`.

---

## Periphery contract: Router

The Periphery contract is the API for Uniswap. You could call the Core contracts directly but that's more complicated (periphery provides wrapper functions) and more dangerous (you could lose money if you're not careful).

Core contracts have checks to make sure they aren't cheated on. But they don't provide checks for anybody else. Those checks are in the periphery. So if you don't want to lose money, use the periphery contract to interact with Uniswap.

![](https://miro.medium.com/max/1400/1*CcfWX3ZW3sVpbi3HquPe5g@2x.png)

- This contract has a bunch of similar functions for adding liquidity, removing liquidity, and swapping tokens. Different variants of functions are for different trading/liquidity preferences.
- I removed the body of most functions because they are pretty similar.

---

## Uniswap v3 Source Code Analysis (briefly)

- https://youtu.be/WCLsIcjLSXc

## Credits

[Solidity - Events](https://www.tutorialspoint.com/solidity/solidity_events.htm)

[Solidity by Example - Events](https://solidity-by-example.org/events/)

https://medium.com/@chiqing/uniswap-v2-explained-beginner-friendly-b5d2cb64fe0f

https://betterprogramming.pub/uniswap-smart-contract-breakdown-ea20edf1a0ff

https://betterprogramming.pub/uniswap-smart-contract-breakdown-part-2-b9ea2fca65d1

https://coinsbench.com/erc20-smart-contract-breakdown-9dab65cec671

https://ethereum.org/en/developers/tutorials/uniswap-v2-annotated-code/

https://ilamanov.medium.com/difference-between-uniswap-versions-877619a5bce2

https://ilamanov.medium.com/how-uniswap-pools-are-implemented-b50907c7903a
